% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GDI-plot.R, R/cellsUniformClustering.R,
%   R/checkClusterUniformity.R, R/mergeUniformCellsClusters.R
\name{UniformClusters}
\alias{UniformClusters}
\alias{GDIPlot}
\alias{cellsUniformClustering}
\alias{checkClusterUniformity}
\alias{mergeUniformCellsClusters}
\title{Uniform Clusters}
\usage{
GDIPlot(
  objCOTAN,
  genes,
  condition = "",
  statType = "S",
  GDIThreshold = 1.4,
  GDIIn = NULL
)

cellsUniformClustering(
  objCOTAN,
  GDIThreshold = 1.4,
  cores = 1L,
  maxIterations = 25L,
  saveObj = TRUE,
  outDir = "."
)

checkClusterUniformity(
  objCOTAN,
  cluster,
  cells,
  GDIThreshold = 1.4,
  cores = 1L,
  saveObj = TRUE,
  outDir = "."
)

mergeUniformCellsClusters(
  objCOTAN,
  clusters = NULL,
  GDIThreshold = 1.4,
  cores = 1L,
  distance = "cosine",
  hclustMethod = "ward.D2",
  saveObj = TRUE,
  outDir = "."
)
}
\arguments{
\item{objCOTAN}{a \code{COTAN} object}

\item{genes}{a named \code{list} of genes to label. Each array will have different
color.}

\item{condition}{a string corresponding to the condition/sample (it is used
only for the title).}

\item{statType}{type of statistic to be used. Default is "S": Pearson's
chi-squared test statistics. "G" is G-test statistics}

\item{GDIThreshold}{the threshold level that discriminates uniform clusters.
It defaults to \eqn{1.4}}

\item{GDIIn}{when the \code{GDI} data frame was already calculated, it can be put
here to speed up the process (default is \code{NULL})}

\item{cores}{number cores used}

\item{maxIterations}{Max number of re-clustering iterations. It defaults to
\eqn{25}.}

\item{saveObj}{Boolean flag; when \code{TRUE} saves intermediate analyses and
plots to file}

\item{outDir}{an existing directory for the analysis output. The effective
output will be paced in a sub-folder.}

\item{cluster}{the tag of the \emph{cluster}}

\item{cells}{the cells belonging to the \emph{cluster}}

\item{clusters}{The \emph{clusterization} to merge. If not given the last
available \emph{clusterization} will be used, as it is probably the most
significant!}

\item{distance}{type of distance to use (default is \code{"cosine"}, \code{"euclidean"}
and the others from \code{\link[parallelDist:parDist]{parallelDist::parDist()}} are also available)}

\item{hclustMethod}{It defaults is \code{"ward.D2"} but can be any of the methods
defined by the \code{\link[stats:hclust]{stats::hclust()}} function.}
}
\value{
\code{GDIPlot()} returns a \code{ggplot2} object

\code{cellsUniformClustering()} returns the newly found \emph{clusterization}

\code{checkClusterUniformity} returns \code{TRUE} when the \emph{cluster} is
\strong{uniform}, \code{FALSE} otherwise.

a \code{list} with "clusters", "coexDF" and "pValueDF"
}
\description{
This group of functions takes in input a \code{COTAN} object and
handle the task of dividing the dataset into \strong{Uniform Clusters}, that is
\emph{clusters} that have an homogeneous genes' expression. This condition is
checked by calculating the \code{GDI} of the \emph{cluster} and verifying that no
more than a small fraction of the genes have their \code{GDI} level above the
given \code{GDIThreshold}
}
\details{
\code{GDIPlot()} directly evaluates and plots the \code{GDI} for a sample.

\code{cellsUniformClustering()} finds a \strong{Uniform} \emph{clusterizations} by
means of the \code{GDI}. Once a preliminary \emph{clusterization} is obtained from
the \code{Seurat} package methods, each \emph{cluster} is checked for \strong{uniformity}
via the function \code{\link[=checkClusterUniformity]{checkClusterUniformity()}}. Once all \emph{clusters} are
checked, all cells from the \strong{non-uniform} clusters are pooled together
for another iteration of the entire process, until all \emph{clusters} are
deemed \strong{uniform}. In the case only a few cells are left out (\eqn{\leq
  50}), those are flagged as \code{"not_clustered"} and the process is stopped.

\code{checkClusterUniformity()} takes a \code{COTAN} object and a cells'
\emph{cluster} and checks whether the latter is \strong{uniform} by \code{GDI}. The
function runs \code{COTAN} to check whether the \code{GDI} is lower than the given
\code{GDIThreshold} for the \eqn{99\%} of the genes. If the \code{GDI} results to be
too high for too many genes, the \emph{cluster} is deemed \strong{non-uniform}.

\code{mergeUniformCellsClusters()} takes in a \strong{uniform}
\emph{clusterization} and iteratively checks whether merging two \emph{near clusters}
would form a \strong{uniform} \emph{cluster} still. This function uses the \emph{cosine
distance} and the \code{\link[stats:hclust]{stats::hclust()}} function to establish \emph{near clusters
pairs}. It will use the \code{\link[=checkClusterUniformity]{checkClusterUniformity()}} function to check
whether the merged \emph{clusters} are \strong{uniform}. The function will stop once
no \emph{near pairs} of clusters are mergeable.
}
\examples{
data("test.dataset")

objCOTAN <- automaticCOTANObjectCreation(raw = test.dataset,
                                         GEO = "S",
                                         sequencingMethod = "10X",
                                         sampleCondition = "Test",
                                         cores = 12,
                                         saveObj = FALSE)

groupMarkers <- list(G1 = c("g-000010", "g-000020", "g-000030"),
                     G2 = c("g-000300", "g-000330"),
                     G3 = c("g-000510", "g-000530", "g-000550",
                            "g-000570", "g-000590"))
gdiPlot <- GDIPlot(objCOTAN, genes = groupMarkers, cond = "test")
plot(gdiPlot)

## Here we override the default GDI threshold as a way to speed-up
## calculations as higher threshold implies less stringent uniformity
## It real applications it might be appropriate to change the threshold
## in cases of relatively low genes/cells number, or in cases when an
## rough clusterization is needed in the early satges of the analysis
##
clusters <- cellsUniformClustering(objCOTAN, cores = 12,
                                   GDIThreshold = 1.5, saveObj = FALSE)

checkClusterUniformity(objCOTAN, GDIThreshold = 1.5,
                       cluster = clusters[1],
                       cells = getCells(objCOTAN)[clusters \%in\% clusters[1]],
                       cores = 12,
                       saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN, clName = "uniformClusters",
                              clusters = clusters)

mergedList <- mergeUniformCellsClusters(objCOTAN, GDIThreshold = 1.5,
                                        clusters = clusters,
                                        cores = 12,
                                        distance = "cosine",
                                        hclustMethod = "ward.D2",
                                        saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN, clName = "mergedUniformClusters",
                              clusters = mergedList[["clusters"]],
                              coexDF = mergedList[["coexDF"]])

}
