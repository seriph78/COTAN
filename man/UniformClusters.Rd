% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GDI-plot.R, R/cellsUniformClustering.R,
%   R/checkClusterUniformity.R, R/mergeUniformCellsClusters.R,
%   R/reorderClusterization.R
\name{UniformClusters}
\alias{UniformClusters}
\alias{GDIPlot}
\alias{cellsUniformClustering}
\alias{checkClusterUniformity}
\alias{mergeUniformCellsClusters}
\alias{reorderClusterization}
\title{Uniform Clusters}
\usage{
GDIPlot(
  objCOTAN,
  genes,
  condition = "",
  statType = "S",
  GDIThreshold = 1.4,
  GDIIn = NULL
)

cellsUniformClustering(
  objCOTAN,
  GDIThreshold = 1.4,
  cores = 1L,
  maxIterations = 25L,
  saveObj = TRUE,
  outDir = "."
)

checkClusterUniformity(
  objCOTAN,
  cluster,
  cells,
  GDIThreshold = 1.4,
  cores = 1L,
  saveObj = TRUE,
  outDir = "."
)

mergeUniformCellsClusters(
  objCOTAN,
  clusters = NULL,
  GDIThreshold = 1.4,
  batchSize = 10L,
  cores = 1L,
  distance = "cosine",
  hclustMethod = "ward.D2",
  saveObj = TRUE,
  outDir = "."
)

reorderClusterization(
  objCOTAN,
  clusters = NULL,
  coexDF = NULL,
  reverse = FALSE,
  keepMinusOne = TRUE,
  distance = "cosine",
  hclustMethod = "ward.D2"
)
}
\arguments{
\item{objCOTAN}{a \code{COTAN} object}

\item{genes}{a named \code{list} of genes to label. Each array will have different
color.}

\item{condition}{a string corresponding to the condition/sample (it is used
only for the title).}

\item{statType}{type of statistic to be used. Default is "S": Pearson's
chi-squared test statistics. "G" is G-test statistics}

\item{GDIThreshold}{the threshold level that discriminates uniform clusters.
It defaults to \eqn{1.4}}

\item{GDIIn}{when the \code{GDI} data frame was already calculated, it can be put
here to speed up the process (default is \code{NULL})}

\item{cores}{number cores used}

\item{maxIterations}{Max number of re-clustering iterations. It defaults to
\eqn{25}.}

\item{saveObj}{Boolean flag; when \code{TRUE} saves intermediate analyses and
plots to file}

\item{outDir}{an existing directory for the analysis output. The effective
output will be paced in a sub-folder.}

\item{cluster}{the tag of the \emph{cluster}}

\item{cells}{the cells belonging to the \emph{cluster}}

\item{clusters}{The \emph{clusterization} to merge. If not given the last
available \emph{clusterization} will be used, as it is probably the most
significant!}

\item{batchSize}{Number pairs to test in a single round. If none of them
succeeds the merge stops}

\item{distance}{type of distance to use (default is \code{"cosine"}, \code{"euclidean"}
and the others from \code{\link[parallelDist:parDist]{parallelDist::parDist()}} are also available)}

\item{hclustMethod}{It defaults is \code{"ward.D2"} but can be any of the methods
defined by the \code{\link[stats:hclust]{stats::hclust()}} function.}

\item{coexDF}{a \code{data.frame} where each column indicates the \code{COEX} for each
of the \emph{clusters} of the \emph{clusterization}. If not available it will be
recalculated}

\item{reverse}{a flag to the output order}

\item{keepMinuOne}{a flag to decide whether to keep the cluster \code{"-1"}
(representing the non-clustered cells) untouched}
}
\value{
\code{GDIPlot()} returns a \code{ggplot2} object

\code{cellsUniformClustering()} returns a \code{list} with 2 elements:
\itemize{
\item "clusters" the newly found cluster labels array
\item "coex" the associated \code{COEX} \code{data.frame}
}

\code{checkClusterUniformity} returns a list with:
\itemize{
\item \code{"isUniform"}: a flag indicating whether the \emph{cluster} is \strong{uniform}
\item \code{"fractionAbove"}: the percentage of genes with \code{GDI} above the threshold
\item \code{"1stPercentile"}: the quantile associated to the highest percentile
}

a \code{list} with "clusters", "coexDF" and "pValueDF"

\code{reorderClusterization()} returns a \code{list} with 2 elements:
\itemize{
\item "clusters" the newly reordered cluster labels array
\item "coex" the associated \code{COEX} \code{data.frame}
}
}
\description{
This group of functions takes in input a \code{COTAN} object and
handle the task of dividing the dataset into \strong{Uniform Clusters}, that is
\emph{clusters} that have an homogeneous genes' expression. This condition is
checked by calculating the \code{GDI} of the \emph{cluster} and verifying that no
more than a small fraction of the genes have their \code{GDI} level above the
given \code{GDIThreshold}
}
\details{
\code{GDIPlot()} directly evaluates and plots the \code{GDI} for a sample.

\code{cellsUniformClustering()} finds a \strong{Uniform} \emph{clusterizations} by
means of the \code{GDI}. Once a preliminary \emph{clusterization} is obtained from
the \code{Seurat} package methods, each \emph{cluster} is checked for \strong{uniformity}
via the function \code{\link[=checkClusterUniformity]{checkClusterUniformity()}}. Once all \emph{clusters} are
checked, all cells from the \strong{non-uniform} clusters are pooled together
for another iteration of the entire process, until all \emph{clusters} are
deemed \strong{uniform}. In the case only a few cells are left out (\eqn{\leq
  50}), those are flagged as \code{"-1"} and the process is stopped.

\code{checkClusterUniformity()} takes a \code{COTAN} object and a cells'
\emph{cluster} and checks whether the latter is \strong{uniform} by \code{GDI}. The
function runs \code{COTAN} to check whether the \code{GDI} is lower than the given
\code{GDIThreshold} for the \eqn{99\%} of the genes. If the \code{GDI} results to be
too high for too many genes, the \emph{cluster} is deemed \strong{non-uniform}.

\code{mergeUniformCellsClusters()} takes in a \strong{uniform}
\emph{clusterization} and iteratively checks whether merging two \emph{near clusters}
would form a \strong{uniform} \emph{cluster} still. This function uses the \emph{cosine
distance} to establish the \emph{nearest clusters pairs}. It will use the
\code{\link[=checkClusterUniformity]{checkClusterUniformity()}} function to check whether the merged \emph{clusters}
are \strong{uniform}. The function will stop once no \emph{near pairs} of clusters
are mergeable in a single batch

\code{reorderClusterization()} takes in a \emph{clusterizations} and reorder
its labels so that in the new order near labels indicate near clusters
according to a \code{DEA} based distance
}
\examples{
data("test.dataset")

objCOTAN <- automaticCOTANObjectCreation(raw = test.dataset,
                                         GEO = "S",
                                         sequencingMethod = "10X",
                                         sampleCondition = "Test",
                                         cores = 12L,
                                         saveObj = FALSE)

groupMarkers <- list(G1 = c("g-000010", "g-000020", "g-000030"),
                     G2 = c("g-000300", "g-000330"),
                     G3 = c("g-000510", "g-000530", "g-000550",
                            "g-000570", "g-000590"))
gdiPlot <- GDIPlot(objCOTAN, genes = groupMarkers, cond = "test")
plot(gdiPlot)

## Here we override the default GDI threshold as a way to speed-up
## calculations as higher threshold implies less stringent uniformity
## It real applications it might be appropriate to change the threshold
## in cases of relatively low genes/cells number, or in cases when an
## rough clusterization is needed in the early satges of the analysis
##

splitList <- cellsUniformClustering(objCOTAN, cores = 12,
                                    GDIThreshold = 1.5, saveObj = FALSE)

clusters <- splitList[["clusters"]]

firstCluster <- getCells(objCOTAN)[clusters \%in\% clusters[[1L]]]
checkClusterUniformity(objCOTAN,
                       GDIThreshold = 1.5,
                       cluster = clusters[[1L]],
                       cells = firstCluster,
                       cores = 12L,
                       saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN,
                              clName = "split",
                              clusters = clusters)

objCOTAN <- addClusterizationCoex(objCOTAN,
                                  clName = "split",
                                  coexDF = splitList[["coexDF"]])

expect_identical(reorderClusterization(objCOTAN)[["clusters"]], clusters)

mergedList <- mergeUniformCellsClusters(objCOTAN,
                                        GDIThreshold = 1.5,
                                        batchSize = 5L,
                                        clusters = clusters,
                                        cores = 12L,
                                        distance = "cosine",
                                        hclustMethod = "ward.D2",
                                        saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN,
                              clName = "merged",
                              clusters = mergedList[["clusters"]],
                              coexDF = mergedList[["coexDF"]])

}
