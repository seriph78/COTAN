% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GDI-plot.R, R/cellsUniformClustering.R,
%   R/checkClusterUniformity.R, R/mergeUniformCellsClusters.R
\name{UniformClusters}
\alias{UniformClusters}
\alias{GDIPlot}
\alias{cellsUniformClustering}
\alias{checkClusterUniformity}
\alias{mergeUniformCellsClusters}
\title{Uniform Clusters}
\usage{
GDIPlot(
  objCOTAN,
  genes,
  condition = "",
  statType = "S",
  GDIThreshold = 1.43,
  GDIIn = NULL
)

cellsUniformClustering(
  objCOTAN,
  GDIThreshold = 1.43,
  cores = 1L,
  maxIterations = 25L,
  optimizeForSpeed = TRUE,
  deviceStr = "cuda",
  initialClusters = NULL,
  initialResolution = 0.8,
  useDEA = TRUE,
  distance = NULL,
  hclustMethod = "ward.D2",
  saveObj = TRUE,
  outDir = "."
)

checkClusterUniformity(
  objCOTAN,
  clusterName,
  cells,
  GDIThreshold = 1.43,
  ratioAboveThreshold = 0.01,
  cores = 1L,
  optimizeForSpeed = TRUE,
  deviceStr = "cuda",
  saveObj = TRUE,
  outDir = "."
)

mergeUniformCellsClusters(
  objCOTAN,
  clusters = NULL,
  GDIThreshold = 1.43,
  batchSize = 0L,
  notMergeable = NULL,
  cores = 1L,
  optimizeForSpeed = TRUE,
  deviceStr = "cuda",
  useDEA = TRUE,
  distance = NULL,
  hclustMethod = "ward.D2",
  saveObj = TRUE,
  outDir = "."
)
}
\arguments{
\item{objCOTAN}{a \code{COTAN} object}

\item{genes}{a named \code{list} of genes to label. Each array will have different
color.}

\item{condition}{a string corresponding to the condition/sample (it is used
only for the title).}

\item{statType}{type of statistic to be used. Default is "S": Pearson's
chi-squared test statistics. "G" is G-test statistics}

\item{GDIThreshold}{the threshold level that discriminates uniform clusters.
It defaults to \eqn{1.43}}

\item{GDIIn}{when the \code{GDI} data frame was already calculated, it can be put
here to speed up the process (default is \code{NULL})}

\item{cores}{number of cores to use. Default is 1.}

\item{maxIterations}{max number of re-clustering iterations. It defaults to
\eqn{25}}

\item{optimizeForSpeed}{Boolean; when \code{TRUE} \code{COTAN} tries to use the \code{torch}
library to run the matrix calculations. Otherwise, or when the library is
not available will run the slower legacy code}

\item{deviceStr}{On the \code{torch} library enforces which device to use to run
the calculations. Possible values are \code{"cpu"} to us the system \emph{CPU},
\code{"cuda"} to use the system \emph{GPUs} or something like \code{"cuda:0"} to restrict
to a specific device}

\item{initialClusters}{an existing \emph{clusterization} to use as starting point:
the \emph{clusters} deemed \strong{uniform} will be kept and the rest processed as
normal}

\item{initialResolution}{a number indicating how refined are the clusters
before checking for \strong{uniformity}. It defaults to \eqn{0.8}, the same as
\code{\link[Seurat:FindClusters]{Seurat::FindClusters()}}}

\item{useDEA}{Boolean indicating whether to use the \emph{DEA} to define the
distance; alternatively it will use the average \emph{Zero-One} counts, that is
faster but less precise.}

\item{distance}{type of distance to use. Default is \code{"cosine"} for \emph{DEA} and
\code{"euclidean"} for \emph{Zero-One}. Can be chosen among those supported by
\code{\link[parallelDist:parDist]{parallelDist::parDist()}}}

\item{hclustMethod}{It defaults is \code{"ward.D2"} but can be any of the methods
defined by the \code{\link[stats:hclust]{stats::hclust()}} function.}

\item{saveObj}{Boolean flag; when \code{TRUE} saves intermediate analyses and
plots to file}

\item{outDir}{an existing directory for the analysis output. The effective
output will be paced in a sub-folder.}

\item{clusterName}{the tag of the \emph{cluster}}

\item{cells}{the cells belonging to the \emph{cluster}}

\item{ratioAboveThreshold}{the fraction of genes allowed to be above the
\code{GDIThreshold}. It defaults to \eqn{1\%}}

\item{clusters}{The \emph{clusterization} to merge. If not given the last
available \emph{clusterization} will be used, as it is probably the most
significant!}

\item{batchSize}{Number pairs to test in a single round. If none of them
succeeds the merge stops. Defaults to \eqn{2 (\#cl)^{2/3}}}

\item{notMergeable}{An array of names of merged clusters that are already
known for not being uniform. Useful to restart the \emph{merging} process after
an interruption.}
}
\value{
\code{GDIPlot()} returns a \code{ggplot2} object

\code{cellsUniformClustering()} returns a \code{list} with 2 elements:
\itemize{
\item \code{"clusters"} the newly found cluster labels array
\item \code{"coex"} the associated \code{COEX} \code{data.frame}
}

\code{checkClusterUniformity} returns a list with:
\itemize{
\item \code{"isUniform"}: a flag indicating whether the \emph{cluster} is \strong{uniform}
\item \code{"fractionAbove"}: the percentage of genes with \code{GDI} above the threshold
\item \code{"ratioQuantile"}: the quantile associated to the high quantile
associated to given ratio
\item \code{"size"}: the number of cells in the cluster
}

a \code{list} with:
\itemize{
\item \code{"clusters"} the merged cluster labels array
\item \code{"coex"} the associated \code{COEX} \code{data.frame}
}
}
\description{
This group of functions takes in input a \code{COTAN} object and
handle the task of dividing the dataset into \strong{Uniform Clusters}, that is
\emph{clusters} that have an homogeneous genes' expression. This condition is
checked by calculating the \code{GDI} of the \emph{cluster} and verifying that no
more than a small fraction of the genes have their \code{GDI} level above the
given \code{GDIThreshold}
}
\details{
\code{GDIPlot()} directly evaluates and plots the \code{GDI} for a sample.

\code{cellsUniformClustering()} finds a \strong{Uniform} \emph{clusterizations} by
means of the \code{GDI}. Once a preliminary \emph{clusterization} is obtained from
the \code{Seurat-package} methods, each \emph{cluster} is checked for \strong{uniformity}
via the function \code{\link[=checkClusterUniformity]{checkClusterUniformity()}}. Once all \emph{clusters} are
checked, all cells from the \strong{non-uniform} clusters are pooled together
for another iteration of the entire process, until all \emph{clusters} are
deemed \strong{uniform}. In the case only a few cells are left out (\eqn{\leq
  50}), those are flagged as \code{"-1"} and the process is stopped.

\code{checkClusterUniformity()} takes a \code{COTAN} object and a cells'
\emph{cluster} and checks whether the latter is \strong{uniform} by \code{GDI}. The
function runs \code{COTAN} to check whether the \code{GDI} is lower than the given
\code{GDIThreshold} (1.43) for all but at the most \code{ratioAboveThreshold}
(\eqn{1\%}) genes. If the \code{GDI} results to be too high for too many genes,
the \emph{cluster} is deemed
\strong{non-uniform}.

\code{mergeUniformCellsClusters()} takes in a \strong{uniform}
\emph{clusterization} and iteratively checks whether merging two \emph{near clusters}
would form a \strong{uniform} \emph{cluster} still. This function uses the \emph{cosine
distance} to establish the \emph{nearest clusters pairs}. It will use the
\code{\link[=checkClusterUniformity]{checkClusterUniformity()}} function to check whether the merged \emph{clusters}
are \strong{uniform}. The function will stop once no \emph{near pairs} of clusters
are mergeable in a single batch
}
\examples{
data("test.dataset")

objCOTAN <- automaticCOTANObjectCreation(raw = test.dataset,
                                         GEO = "S",
                                         sequencingMethod = "10X",
                                         sampleCondition = "Test",
                                         cores = 6L,
                                         saveObj = FALSE)

groupMarkers <- list(G1 = c("g-000010", "g-000020", "g-000030"),
                     G2 = c("g-000300", "g-000330"),
                     G3 = c("g-000510", "g-000530", "g-000550",
                            "g-000570", "g-000590"))
gdiPlot <- GDIPlot(objCOTAN, genes = groupMarkers, cond = "test")
plot(gdiPlot)

## Here we override the default GDI threshold as a way to speed-up
## calculations as higher threshold implies less stringent uniformity
## It real applications it might be appropriate to change the threshold
## in cases of relatively low genes/cells number, or in cases when an
## rough clusterization is needed in the early satges of the analysis
##

splitList <- cellsUniformClustering(objCOTAN, cores = 6L,
                                    optimizeForSpeed = TRUE,
                                    deviceStr = "cuda",
                                    initialResolution = 0.8,
                                    GDIThreshold = 1.46, saveObj = FALSE)

clusters <- splitList[["clusters"]]

firstCluster <- getCells(objCOTAN)[clusters \%in\% clusters[[1L]]]
firstClusterIsUniform <-
  checkClusterUniformity(objCOTAN, GDIThreshold = 1.46,
                         ratioAboveThreshold = 0.01,
                         cluster = clusters[[1L]], cells = firstCluster,
                         cores = 6L, optimizeForSpeed = TRUE,
                         deviceStr = "cuda", saveObj = FALSE)[["isUniform"]]

objCOTAN <- addClusterization(objCOTAN,
                              clName = "split",
                              clusters = clusters)

objCOTAN <- addClusterizationCoex(objCOTAN,
                                  clName = "split",
                                  coexDF = splitList[["coex"]])

identical(reorderClusterization(objCOTAN)[["clusters"]], clusters)

mergedList <- mergeUniformCellsClusters(objCOTAN,
                                        GDIThreshold = 1.46,
                                        batchSize = 5L,
                                        clusters = clusters,
                                        cores = 6L,
                                        optimizeForSpeed = TRUE,
                                        deviceStr = "cpu",
                                        distance = "cosine",
                                        hclustMethod = "ward.D2",
                                        saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN,
                              clName = "merged",
                              clusters = mergedList[["clusters"]],
                              coexDF = mergedList[["coex"]])

identical(reorderClusterization(objCOTAN), mergedList)

}
